// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: payment.sql

package sqlc

import (
	"context"

	"gopkg.in/guregu/null.v4/zero"
)

const paymentGetAll = `-- name: PaymentGetAll :many
SELECT id, organization_id, amount, requisites, status, type, created_at, updated_at, deleted_at
FROM payments
WHERE deleted_at IS NULL
    AND organization_id = $1
    AND CASE
        WHEN $2::INTEGER != 0 THEN STATUS = $2
        ELSE TRUE
    END
    AND CASE
        WHEN $3::INTEGER != 0 THEN TYPE = $3
        ELSE TRUE
    END
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type PaymentGetAllParams struct {
	OrganizationID string `json:"organization_id"`
	Status         int32  `json:"status"`
	Type           int32  `json:"type"`
	Offset         int32  `json:"offset"`
	Limit          int32  `json:"limit"`
}

func (q *Queries) PaymentGetAll(ctx context.Context, arg PaymentGetAllParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, paymentGetAll,
		arg.OrganizationID,
		arg.Status,
		arg.Type,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Amount,
			&i.Requisites,
			&i.Status,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paymentGetAllCount = `-- name: PaymentGetAllCount :one
SELECT COUNT(*)
FROM payments
WHERE deleted_at IS NULL
    AND organization_id = $1
    AND CASE
        WHEN $2::INTEGER != 0 THEN STATUS = $2
        ELSE TRUE
    END
    AND CASE
        WHEN $3::INTEGER != 0 THEN TYPE = $3
        ELSE TRUE
    END
`

type PaymentGetAllCountParams struct {
	OrganizationID string `json:"organization_id"`
	Status         int32  `json:"status"`
	Type           int32  `json:"type"`
}

func (q *Queries) PaymentGetAllCount(ctx context.Context, arg PaymentGetAllCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, paymentGetAllCount, arg.OrganizationID, arg.Status, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const paymentGetOne = `-- name: PaymentGetOne :one
SELECT id, organization_id, amount, requisites, status, type, created_at, updated_at, deleted_at
FROM payments
WHERE id = $1
`

func (q *Queries) PaymentGetOne(ctx context.Context, id string) (Payment, error) {
	row := q.db.QueryRow(ctx, paymentGetOne, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Amount,
		&i.Requisites,
		&i.Status,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const paymentInsertOne = `-- name: PaymentInsertOne :one
INSERT INTO payments (
        organization_id,
        amount,
        requisites,
        STATUS,
        TYPE
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5
    )
RETURNING id
`

type PaymentInsertOneParams struct {
	OrganizationID string      `json:"organization_id"`
	Amount         int64       `json:"amount"`
	Requisites     zero.String `json:"requisites"`
	Status         int32       `json:"status"`
	Type           int32       `json:"type"`
}

func (q *Queries) PaymentInsertOne(ctx context.Context, arg PaymentInsertOneParams) (string, error) {
	row := q.db.QueryRow(ctx, paymentInsertOne,
		arg.OrganizationID,
		arg.Amount,
		arg.Requisites,
		arg.Status,
		arg.Type,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}
