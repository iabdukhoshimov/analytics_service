// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package sqlc

import (
	"context"

	"gopkg.in/guregu/null.v4/zero"
)

const userDeleteOne = `-- name: UserDeleteOne :exec
UPDATE users
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) UserDeleteOne(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, userDeleteOne, id)
	return err
}

const userGetAll = `-- name: UserGetAll :many
SELECT id, first_name, last_name, second_name, profile_picture, inn, email, phone_number, role_id, hashed_password, status, region_id, created_at, updated_at, deleted_at
FROM users
WHERE deleted_at IS NULL
    AND CASE
        WHEN $1::VARCHAR != '' THEN first_name ILIKE '%' || $1 || '%'
        OR second_name ILIKE '%' || $1 || '%'
        OR last_name ILIKE '%' || $1 || '%'
        OR phone_number ILIKE '%' || $1 || '%'
        OR email ILIKE '%' || $1 || '%'
        ELSE TRUE
    END
    AND CASE
        WHEN $2::INTEGER != 0 THEN region_id = $2
        ELSE TRUE
    END
LIMIT $4 OFFSET $3
`

type UserGetAllParams struct {
	Search   string `json:"search"`
	RegionID int32  `json:"region_id"`
	Offset   int32  `json:"offset"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) UserGetAll(ctx context.Context, arg UserGetAllParams) ([]User, error) {
	rows, err := q.db.Query(ctx, userGetAll,
		arg.Search,
		arg.RegionID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.SecondName,
			&i.ProfilePicture,
			&i.Inn,
			&i.Email,
			&i.PhoneNumber,
			&i.RoleID,
			&i.HashedPassword,
			&i.Status,
			&i.RegionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetAllCount = `-- name: UserGetAllCount :one
SELECT COUNT(*)
FROM users
WHERE deleted_at IS NULL
    AND CASE
        WHEN $1::VARCHAR != '' THEN first_name ILIKE '%' || $1 || '%'
        OR second_name ILIKE '%' || $1 || '%'
        OR last_name ILIKE '%' || $1 || '%'
        OR phone_number ILIKE '%' || $1 || '%'
        OR email ILIKE '%' || $1 || '%'
        ELSE TRUE
    END
    AND CASE
        WHEN $2::INTEGER != 0 THEN region_id = $2
        ELSE TRUE
    END
`

type UserGetAllCountParams struct {
	Search   string `json:"search"`
	RegionID int32  `json:"region_id"`
}

func (q *Queries) UserGetAllCount(ctx context.Context, arg UserGetAllCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, userGetAllCount, arg.Search, arg.RegionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const userGetOne = `-- name: UserGetOne :one
SELECT id, first_name, last_name, second_name, profile_picture, inn, email, phone_number, role_id, hashed_password, status, region_id, created_at, updated_at, deleted_at
FROM users
WHERE id = $1
`

func (q *Queries) UserGetOne(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, userGetOne, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.SecondName,
		&i.ProfilePicture,
		&i.Inn,
		&i.Email,
		&i.PhoneNumber,
		&i.RoleID,
		&i.HashedPassword,
		&i.Status,
		&i.RegionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const userGetOneByEmail = `-- name: UserGetOneByEmail :one
SELECT id, first_name, last_name, second_name, profile_picture, inn, email, phone_number, role_id, hashed_password, status, region_id, created_at, updated_at, deleted_at
FROM users
WHERE email = $1
`

func (q *Queries) UserGetOneByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, userGetOneByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.SecondName,
		&i.ProfilePicture,
		&i.Inn,
		&i.Email,
		&i.PhoneNumber,
		&i.RoleID,
		&i.HashedPassword,
		&i.Status,
		&i.RegionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const userInsertOne = `-- name: UserInsertOne :one
INSERT INTO users (
        first_name,
        second_name,
        last_name,
        phone_number,
        email,
        region_id,
        profile_picture,
        hashed_password
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
RETURNING id
`

type UserInsertOneParams struct {
	FirstName      string      `json:"first_name"`
	SecondName     string      `json:"second_name"`
	LastName       string      `json:"last_name"`
	PhoneNumber    string      `json:"phone_number"`
	Email          string      `json:"email"`
	RegionID       int32       `json:"region_id"`
	ProfilePicture zero.String `json:"profile_picture"`
	HashedPassword string      `json:"hashed_password"`
}

func (q *Queries) UserInsertOne(ctx context.Context, arg UserInsertOneParams) (string, error) {
	row := q.db.QueryRow(ctx, userInsertOne,
		arg.FirstName,
		arg.SecondName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Email,
		arg.RegionID,
		arg.ProfilePicture,
		arg.HashedPassword,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const userUpdateOne = `-- name: UserUpdateOne :exec
UPDATE users
SET first_name = COALESCE($1, first_name),
    second_name = COALESCE($2, second_name),
    last_name = COALESCE($3, last_name),
    phone_number = COALESCE($4, phone_number),
    email = COALESCE($5, email),
    region_id = COALESCE($6, region_id),
    profile_picture = COALESCE($7, profile_picture),
    hashed_password = COALESCE($8, hashed_password),
    updated_at = NOW()
WHERE id = $9
`

type UserUpdateOneParams struct {
	FirstName      zero.String `json:"first_name"`
	SecondName     zero.String `json:"second_name"`
	LastName       zero.String `json:"last_name"`
	PhoneNumber    zero.String `json:"phone_number"`
	Email          zero.String `json:"email"`
	RegionID       zero.Int    `json:"region_id"`
	ProfilePicture zero.String `json:"profile_picture"`
	HashedPassword zero.String `json:"hashed_password"`
	ID             string      `json:"id"`
}

func (q *Queries) UserUpdateOne(ctx context.Context, arg UserUpdateOneParams) error {
	_, err := q.db.Exec(ctx, userUpdateOne,
		arg.FirstName,
		arg.SecondName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Email,
		arg.RegionID,
		arg.ProfilePicture,
		arg.HashedPassword,
		arg.ID,
	)
	return err
}
