// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: declaration.sql

package sqlc

import (
	"context"

	"gopkg.in/guregu/null.v4/zero"
)

const declarationGetAll = `-- name: DeclarationGetAll :many
SELECT d.id, d.organization_id, d.danger_rate, d.reasons_of_danger, d.converage_of_the_danger_area, d.proof, d.location_info, d.residents_info, d.life_insurance, d.tech_document, d.status, d.created_at, d.updated_at, d.deleted_at,
    o.name AS organization_name
FROM declaration d
    LEFT JOIN organization o ON o.id = d.organization_id
    AND o.deleted_at IS NULL
WHERE d.deleted_at IS NULL
    AND d.organization_id = $1
    AND o.id IS NOT NULL
LIMIT $3 OFFSET $2
`

type DeclarationGetAllParams struct {
	OrganizationID string `json:"organization_id"`
	Offset         int32  `json:"offset"`
	Limit          int32  `json:"limit"`
}

type DeclarationGetAllRow struct {
	ID                       string      `json:"id"`
	OrganizationID           string      `json:"organization_id"`
	DangerRate               int32       `json:"danger_rate"`
	ReasonsOfDanger          zero.String `json:"reasons_of_danger"`
	ConverageOfTheDangerArea zero.String `json:"converage_of_the_danger_area"`
	Proof                    string      `json:"proof"`
	LocationInfo             zero.String `json:"location_info"`
	ResidentsInfo            zero.String `json:"residents_info"`
	LifeInsurance            zero.String `json:"life_insurance"`
	TechDocument             zero.String `json:"tech_document"`
	Status                   int32       `json:"status"`
	CreatedAt                zero.Time   `json:"created_at"`
	UpdatedAt                zero.Time   `json:"updated_at"`
	DeletedAt                zero.Time   `json:"deleted_at"`
	OrganizationName         zero.String `json:"organization_name"`
}

func (q *Queries) DeclarationGetAll(ctx context.Context, arg DeclarationGetAllParams) ([]DeclarationGetAllRow, error) {
	rows, err := q.db.Query(ctx, declarationGetAll, arg.OrganizationID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeclarationGetAllRow
	for rows.Next() {
		var i DeclarationGetAllRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.DangerRate,
			&i.ReasonsOfDanger,
			&i.ConverageOfTheDangerArea,
			&i.Proof,
			&i.LocationInfo,
			&i.ResidentsInfo,
			&i.LifeInsurance,
			&i.TechDocument,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const declarationGetAllCount = `-- name: DeclarationGetAllCount :one
SELECT COUNT(*)
FROM declaration d
    LEFT JOIN organization o ON o.id = d.organization_id
    AND o.deleted_at IS NULL
WHERE d.deleted_at IS NULL
    AND d.organization_id = $1
    AND o.id IS NOT NULL
`

func (q *Queries) DeclarationGetAllCount(ctx context.Context, organizationID string) (int64, error) {
	row := q.db.QueryRow(ctx, declarationGetAllCount, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const declarationGetOne = `-- name: DeclarationGetOne :one
SELECT d.id, d.organization_id, d.danger_rate, d.reasons_of_danger, d.converage_of_the_danger_area, d.proof, d.location_info, d.residents_info, d.life_insurance, d.tech_document, d.status, d.created_at, d.updated_at, d.deleted_at,
    o.name AS organization_name
FROM declaration AS d
    LEFT JOIN organization o ON o.id = d.organization_id
WHERE d.id = $1
`

type DeclarationGetOneRow struct {
	ID                       string      `json:"id"`
	OrganizationID           string      `json:"organization_id"`
	DangerRate               int32       `json:"danger_rate"`
	ReasonsOfDanger          zero.String `json:"reasons_of_danger"`
	ConverageOfTheDangerArea zero.String `json:"converage_of_the_danger_area"`
	Proof                    string      `json:"proof"`
	LocationInfo             zero.String `json:"location_info"`
	ResidentsInfo            zero.String `json:"residents_info"`
	LifeInsurance            zero.String `json:"life_insurance"`
	TechDocument             zero.String `json:"tech_document"`
	Status                   int32       `json:"status"`
	CreatedAt                zero.Time   `json:"created_at"`
	UpdatedAt                zero.Time   `json:"updated_at"`
	DeletedAt                zero.Time   `json:"deleted_at"`
	OrganizationName         zero.String `json:"organization_name"`
}

func (q *Queries) DeclarationGetOne(ctx context.Context, id string) (DeclarationGetOneRow, error) {
	row := q.db.QueryRow(ctx, declarationGetOne, id)
	var i DeclarationGetOneRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.DangerRate,
		&i.ReasonsOfDanger,
		&i.ConverageOfTheDangerArea,
		&i.Proof,
		&i.LocationInfo,
		&i.ResidentsInfo,
		&i.LifeInsurance,
		&i.TechDocument,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.OrganizationName,
	)
	return i, err
}

const declarationInsertOne = `-- name: DeclarationInsertOne :one
INSERT INTO declaration (
        organization_id,
        danger_rate,
        reasons_of_danger,
        converage_of_the_danger_area,
        proof,
        location_info,
        residents_info,
        life_insurance,
        tech_document
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    )
RETURNING id
`

type DeclarationInsertOneParams struct {
	OrganizationID           string      `json:"organization_id"`
	DangerRate               int32       `json:"danger_rate"`
	ReasonsOfDanger          zero.String `json:"reasons_of_danger"`
	ConverageOfTheDangerArea zero.String `json:"converage_of_the_danger_area"`
	Proof                    string      `json:"proof"`
	LocationInfo             zero.String `json:"location_info"`
	ResidentsInfo            zero.String `json:"residents_info"`
	LifeInsurance            zero.String `json:"life_insurance"`
	TechDocument             zero.String `json:"tech_document"`
}

func (q *Queries) DeclarationInsertOne(ctx context.Context, arg DeclarationInsertOneParams) (string, error) {
	row := q.db.QueryRow(ctx, declarationInsertOne,
		arg.OrganizationID,
		arg.DangerRate,
		arg.ReasonsOfDanger,
		arg.ConverageOfTheDangerArea,
		arg.Proof,
		arg.LocationInfo,
		arg.ResidentsInfo,
		arg.LifeInsurance,
		arg.TechDocument,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}
