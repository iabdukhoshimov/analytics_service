// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: license.sql

package sqlc

import (
	"context"

	"gopkg.in/guregu/null.v4/zero"
)

const licenseGetAll = `-- name: LicenseGetAll :many
SELECT id, document_number, granted_date, lifetime, organization_name, stir_number, reestr_number, work_category, doc_file, license_type, created_at, updated_at, deleted_at
FROM license
WHERE TRUE
    AND CASE
        WHEN $1::VARCHAR != '' THEN document_number ILIKE '%' || $1 || '%'
        OR organization_name ILIKE '%' || $1 || '%'
        OR stir_number ILIKE '%' || $1 || '%'
        OR reestr_number ILIKE '%' || $1 || '%'
        ELSE TRUE
    END
    AND CASE
        WHEN $2::INTEGER != 0 THEN license_type = $2
        ELSE TRUE
    END
LIMIT $4 OFFSET $3
`

type LicenseGetAllParams struct {
	Search      string `json:"search"`
	LicenseType int32  `json:"license_type"`
	Offset      int32  `json:"offset"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) LicenseGetAll(ctx context.Context, arg LicenseGetAllParams) ([]License, error) {
	rows, err := q.db.Query(ctx, licenseGetAll,
		arg.Search,
		arg.LicenseType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []License
	for rows.Next() {
		var i License
		if err := rows.Scan(
			&i.ID,
			&i.DocumentNumber,
			&i.GrantedDate,
			&i.Lifetime,
			&i.OrganizationName,
			&i.StirNumber,
			&i.ReestrNumber,
			&i.WorkCategory,
			&i.DocFile,
			&i.LicenseType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const licenseGetAllCount = `-- name: LicenseGetAllCount :one
SELECT COUNT(*)
FROM license
WHERE TRUE
    AND CASE
        WHEN $1::VARCHAR != '' THEN document_number ILIKE '%' || $1 || '%'
        OR organization_name ILIKE '%' || $1 || '%'
        OR stir_number ILIKE '%' || $1 || '%'
        OR reestr_number ILIKE '%' || $1 || '%'
        ELSE TRUE
    END
    AND CASE
        WHEN $2::INTEGER != 0 THEN license_type = $2
        ELSE TRUE
    END
`

type LicenseGetAllCountParams struct {
	Search      string `json:"search"`
	LicenseType int32  `json:"license_type"`
}

func (q *Queries) LicenseGetAllCount(ctx context.Context, arg LicenseGetAllCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, licenseGetAllCount, arg.Search, arg.LicenseType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const licenseGetOne = `-- name: LicenseGetOne :one
SELECT id, document_number, granted_date, lifetime, organization_name, stir_number, reestr_number, work_category, doc_file, license_type, created_at, updated_at, deleted_at
FROM license
WHERE id = $1
`

func (q *Queries) LicenseGetOne(ctx context.Context, id string) (License, error) {
	row := q.db.QueryRow(ctx, licenseGetOne, id)
	var i License
	err := row.Scan(
		&i.ID,
		&i.DocumentNumber,
		&i.GrantedDate,
		&i.Lifetime,
		&i.OrganizationName,
		&i.StirNumber,
		&i.ReestrNumber,
		&i.WorkCategory,
		&i.DocFile,
		&i.LicenseType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const licenseInsertOne = `-- name: LicenseInsertOne :one
INSERT INTO license (
        document_number,
        granted_date,
        lifetime,
        organization_name,
        stir_number,
        reestr_number,
        work_category,
        doc_file,
        license_type
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    )
RETURNING id
`

type LicenseInsertOneParams struct {
	DocumentNumber   zero.String `json:"document_number"`
	GrantedDate      zero.Time   `json:"granted_date"`
	Lifetime         zero.Int    `json:"lifetime"`
	OrganizationName string      `json:"organization_name"`
	StirNumber       zero.String `json:"stir_number"`
	ReestrNumber     zero.String `json:"reestr_number"`
	WorkCategory     zero.String `json:"work_category"`
	DocFile          zero.String `json:"doc_file"`
	LicenseType      int32       `json:"license_type"`
}

func (q *Queries) LicenseInsertOne(ctx context.Context, arg LicenseInsertOneParams) (string, error) {
	row := q.db.QueryRow(ctx, licenseInsertOne,
		arg.DocumentNumber,
		arg.GrantedDate,
		arg.Lifetime,
		arg.OrganizationName,
		arg.StirNumber,
		arg.ReestrNumber,
		arg.WorkCategory,
		arg.DocFile,
		arg.LicenseType,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}
